diff --git a/lwip/custom/lwipopts.h b/lwip/custom/lwipopts.h
index 64e03ec..7b6f8f4 100644
--- a/lwip/custom/lwipopts.h
+++ b/lwip/custom/lwipopts.h
@@ -67,4 +67,8 @@
 #define MEM_LIBC_MALLOC 1
 #define MEMP_MEM_MALLOC 1
 
+#define CHECKSUM_CHECK_IP 0
+#define CHECKSUM_CHECK_UDP 0
+#define CHECKSUM_CHECK_TCP 0
+
 #endif
diff --git a/misc/ipv4_proto.h b/misc/ipv4_proto.h
index fea7260..9b9a3a5 100644
--- a/misc/ipv4_proto.h
+++ b/misc/ipv4_proto.h
@@ -127,6 +127,7 @@ static int ipv4_check (uint8_t *data, int data_len, struct ipv4_header *out_head
         return 0;
     }
     
+#if CHECKSUM_CHECK_IP
     // check checksum
     uint16_t checksum_in_packet = out_header->checksum;
     out_header->checksum = hton16(0);
@@ -135,6 +136,7 @@ static int ipv4_check (uint8_t *data, int data_len, struct ipv4_header *out_head
     if (checksum_in_packet != checksum_computed) {
         return 0;
     }
+#endif
     
     *out_payload = data + header_len;
     *out_payload_len = total_length - header_len;
diff --git a/misc/version.h b/misc/version.h
index 1079ab0..30e1a0a 100644
--- a/misc/version.h
+++ b/misc/version.h
@@ -34,8 +34,8 @@
 #ifndef BADVPN_MISC_VERSION_H
 #define BADVPN_MISC_VERSION_H
 
-#define GLOBAL_PRODUCT_NAME "BadVPN"
-#define GLOBAL_VERSION "1.999.130"
+#define GLOBAL_PRODUCT_NAME "iMut"
+#define GLOBAL_VERSION "(Build: " __DATE__ " " __TIME__ ")"
 #define GLOBAL_COPYRIGHT_NOTICE "Copyright (C) 2010 Ambroz Bizjak <ambrop7@gmail.com>"
 
 #endif
diff --git a/system/BTime.c b/system/BTime.c
index 198341c..a1fa9e7 100644
--- a/system/BTime.c
+++ b/system/BTime.c
@@ -36,20 +36,3 @@ struct _BTime_global btime_global = {
     #endif
 };
 #endif
-
-#ifdef __MACH__
-#include <mach/clock.h>
-#include <mach/mach.h>
-
-int clock_gettime(int clk_id, struct timespec* t)
-{
-    clock_serv_t cclock;
-    mach_timespec_t mts;
-    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);
-    clock_get_time(cclock, &mts);
-    mach_port_deallocate(mach_task_self(), cclock);
-    t->tv_sec = mts.tv_sec;
-    t->tv_nsec = mts.tv_nsec;
-    return 0;
-}
-#endif
diff --git a/system/BTime.h b/system/BTime.h
index 9b0a43b..6998814 100644
--- a/system/BTime.h
+++ b/system/BTime.h
@@ -69,11 +69,6 @@ struct _BTime_global {
     #endif
 };
 
-#ifdef __MACH__
-#define CLOCK_MONOTONIC 1
-int clock_gettime(int clk_id, struct timespec* t);
-#endif
-
 extern struct _BTime_global btime_global;
 
 static void BTime_Init (void)
diff --git a/tun2socks/SocksUdpGwClient.c b/tun2socks/SocksUdpGwClient.c
index cb9fa6d..c620206 100644
--- a/tun2socks/SocksUdpGwClient.c
+++ b/tun2socks/SocksUdpGwClient.c
@@ -2,7 +2,7 @@
  * Copyright (C) Ambroz Bizjak <ambrop7@gmail.com>
  * Contributions:
  * Transparent DNS: Copyright (C) Kerem Hadimli <kerem.hadimli@gmail.com>
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -13,7 +13,7 @@
  * 3. Neither the name of the author nor the
  *    names of its contributors may be used to endorse or promote products
  *    derived from this software without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -36,7 +36,8 @@
 #ifdef BADVPN_SOCKS_UDP_RELAY
 
 #include <misc/socks_proto.h>
-#define CONNECTION_UDP_BUFFER_SIZE 1
+#define CONNECTION_UDP_BUFFER_SIZE 2
+#define CONNECTION_UDP_TIMEOUT 30
 
 #else
 
@@ -54,7 +55,8 @@ static void dgram_handler (SocksUdpGwClient_connection *o, int event);
 static void dgram_handler_received (SocksUdpGwClient_connection *o, uint8_t *data, int data_len);
 static int conaddr_comparator (void *unused, SocksUdpGwClient_conaddr *v1, SocksUdpGwClient_conaddr *v2);
 static SocksUdpGwClient_connection * find_connection (SocksUdpGwClient *o, SocksUdpGwClient_conaddr conaddr);
-static SocksUdpGwClient_connection * reuse_connection (SocksUdpGwClient *o, SocksUdpGwClient_conaddr conaddr);
+static void recycle_connections (SocksUdpGwClient *o);
+static void force_recycle_connection (SocksUdpGwClient *o);
 static void connection_send (SocksUdpGwClient_connection *o, const uint8_t *data, int data_len);
 static void connection_first_job_handler (SocksUdpGwClient_connection *con);
 static SocksUdpGwClient_connection *connection_init (SocksUdpGwClient *client, SocksUdpGwClient_conaddr conaddr, const uint8_t *data, int data_len);
@@ -64,89 +66,102 @@ static void dgram_handler (SocksUdpGwClient_connection *o, int event)
 {
     SocksUdpGwClient *client = o->client;
     ASSERT(client);
-    
+
     DebugObject_Access(&client->d_obj);
-    
+
+#ifndef NDEBUG
     BLog(BLOG_INFO, "UDP error");
+#endif
 }
 
 static void dgram_handler_received (SocksUdpGwClient_connection *o, uint8_t *data, int data_len)
 {
     SocksUdpGwClient *client = o->client;
     ASSERT(client);
-    
+
     DebugObject_Access(&client->d_obj);
     ASSERT(data_len >= 0)
     ASSERT(data_len <= client->udpgw_mtu)
-    
+
     // accept packet
     PacketPassInterface_Done(&o->udp_recv_if);
-    
-    // check header
-    if (data_len < sizeof(struct socks_udp_header)) {
-        BLog(BLOG_ERROR, "missing header");
-        return;
-    }
-    struct socks_udp_header header;
-    memcpy(&header, data, sizeof(header));
-    data += sizeof(header);
-    data_len -= sizeof(header);
-    uint8_t frag = header.frag;
-    uint8_t atyp = header.atyp;
-    
-    // check fragment
-    if (frag) {
-        BLog(BLOG_ERROR, "unexpected frag");
-        return;
-    }
-    
-    // parse address
-    BAddr remote_addr;
-    if (atyp == SOCKS_ATYP_IPV6) {
-        if (data_len < sizeof(struct udpgw_addr_ipv6)) {
-            BLog(BLOG_ERROR, "missing ipv6 address");
+
+    BAddr remote_addr = o->conaddr.remote_addr;
+    if (!o->conaddr.is_dns) {
+        // check header
+        if (data_len < sizeof(struct socks_udp_header)) {
+#ifndef NDEBUG
+            BLog(BLOG_ERROR, "missing header");
+#endif
             return;
         }
-        struct udpgw_addr_ipv6 addr_ipv6;
-        memcpy(&addr_ipv6, data, sizeof(addr_ipv6));
-        data += sizeof(addr_ipv6);
-        data_len -= sizeof(addr_ipv6);
-        BAddr_InitIPv6(&remote_addr, addr_ipv6.addr_ip, addr_ipv6.addr_port);
-    } else {
-        if (data_len < sizeof(struct udpgw_addr_ipv4)) {
-            BLog(BLOG_ERROR, "missing ipv4 address");
+        struct socks_udp_header header;
+        memcpy(&header, data, sizeof(header));
+        data += sizeof(header);
+        data_len -= sizeof(header);
+        uint8_t frag = header.frag;
+        uint8_t atyp = header.atyp;
+
+        // check fragment
+        if (frag) {
+#ifndef NDEBUG
+            BLog(BLOG_ERROR, "unexpected frag");
+#endif
             return;
         }
-        struct udpgw_addr_ipv4 addr_ipv4;
-        memcpy(&addr_ipv4, data, sizeof(addr_ipv4));
-        data += sizeof(addr_ipv4);
-        data_len -= sizeof(addr_ipv4);
-        BAddr_InitIPv4(&remote_addr, addr_ipv4.addr_ip, addr_ipv4.addr_port);
-    }
-    
-    // check remote addr
-    if (!BAddr_Compare(&remote_addr, &o->conaddr.remote_addr)) {
-        BLog(BLOG_ERROR, "remote addr not match");
-        return;
+
+        // parse address
+        if (atyp == SOCKS_ATYP_IPV6) {
+            if (data_len < sizeof(struct udpgw_addr_ipv6)) {
+#ifndef NDEBUG
+                BLog(BLOG_ERROR, "missing ipv6 address");
+#endif
+                return;
+            }
+            struct udpgw_addr_ipv6 addr_ipv6;
+            memcpy(&addr_ipv6, data, sizeof(addr_ipv6));
+            data += sizeof(addr_ipv6);
+            data_len -= sizeof(addr_ipv6);
+            BAddr_InitIPv6(&remote_addr, addr_ipv6.addr_ip, addr_ipv6.addr_port);
+        } else {
+            if (data_len < sizeof(struct udpgw_addr_ipv4)) {
+#ifndef NDEBUG
+                BLog(BLOG_ERROR, "missing ipv4 address");
+#endif
+                return;
+            }
+            struct udpgw_addr_ipv4 addr_ipv4;
+            memcpy(&addr_ipv4, data, sizeof(addr_ipv4));
+            data += sizeof(addr_ipv4);
+            data_len -= sizeof(addr_ipv4);
+            BAddr_InitIPv4(&remote_addr, addr_ipv4.addr_ip, addr_ipv4.addr_port);
+        }
     }
-    
+
     // check remaining data
     if (data_len > client->udp_mtu) {
+#ifndef NDEBUG
         BLog(BLOG_ERROR, "too much data");
+#endif
         return;
     }
-    
+
     // submit to user
     client->handler_received(client->user, o->conaddr.local_addr, remote_addr, data, data_len);
 }
 
 static int conaddr_comparator (void *unused, SocksUdpGwClient_conaddr *v1, SocksUdpGwClient_conaddr *v2)
 {
-    int r = BAddr_CompareOrder(&v1->remote_addr, &v2->remote_addr);
-    if (r) {
-        return r;
+    int cmp = B_COMPARE(v1->is_dns, v2->is_dns);
+    if (cmp) {
+        return cmp;
+    }
+
+    cmp = BAddr_CompareOrder(&v1->local_addr, &v2->local_addr);
+    if (cmp || !v1->is_dns) {
+        return cmp;
     }
-    return BAddr_CompareOrder(&v1->local_addr, &v2->local_addr);
+    return BAddr_CompareOrder(&v1->remote_addr, &v2->remote_addr);
 }
 
 static SocksUdpGwClient_connection * find_connection (SocksUdpGwClient *o, SocksUdpGwClient_conaddr conaddr)
@@ -155,28 +170,36 @@ static SocksUdpGwClient_connection * find_connection (SocksUdpGwClient *o, Socks
     if (!tree_node) {
         return NULL;
     }
-    
+
     return UPPER_OBJECT(tree_node, SocksUdpGwClient_connection, connections_tree_node);
 }
 
-static SocksUdpGwClient_connection * reuse_connection (SocksUdpGwClient *o, SocksUdpGwClient_conaddr conaddr)
+static void recycle_connections (SocksUdpGwClient *o)
+{
+    time_t now = time(NULL);
+    while (1) {
+        LinkedList1Node *node = LinkedList1_GetFirst(&o->connections_list);
+        if (!node) {
+            break;
+        }
+        SocksUdpGwClient_connection *con = UPPER_OBJECT(node, SocksUdpGwClient_connection, connections_list_node);
+        if (!con->last_active_time || now - con->last_active_time <= CONNECTION_UDP_TIMEOUT) {
+            break;
+        }
+        connection_free(con);
+    }
+}
+
+static void force_recycle_connection (SocksUdpGwClient *o)
 {
-    ASSERT(!find_connection(o, conaddr))
     ASSERT(o->num_connections > 0)
-    
+
     // get least recently used connection
     SocksUdpGwClient_connection *con = UPPER_OBJECT(LinkedList1_GetFirst(&o->connections_list), SocksUdpGwClient_connection, connections_list_node);
-    
-    // remove from connections tree by conaddr
-    BAVL_Remove(&o->connections_tree, &con->connections_tree_node);
-    
-    // set new conaddr
-    con->conaddr = conaddr;
-    
-    // insert to connections tree by conaddr
-    ASSERT_EXECUTE(BAVL_Insert(&o->connections_tree, &con->connections_tree_node, NULL))
-    
-    return con;
+
+    if (con) {
+        connection_free(con);
+    }
 }
 
 static void connection_send (SocksUdpGwClient_connection *o, const uint8_t *data, int data_len)
@@ -184,48 +207,57 @@ static void connection_send (SocksUdpGwClient_connection *o, const uint8_t *data
     // get buffer location
     uint8_t *out;
     if (!BufferWriter_StartPacket(&o->udp_send_writer, &out)) {
+#ifndef NDEBUG
         BLog(BLOG_ERROR, "out of UDP buffer");
+#endif
         return;
     }
     int out_pos = 0;
-    
-    // write header
-    BAddr remote_addr = o->conaddr.remote_addr;
-    struct socks_udp_header header;
-    header.rsv = 0;
-    header.frag = 0;
-    if (remote_addr.type == BADDR_TYPE_IPV4) {
-        header.atyp = SOCKS_ATYP_IPV4;
-    } else {
-        header.atyp = SOCKS_ATYP_IPV6;
-    }
-    memcpy(out + out_pos, &header, sizeof(header));
-    out_pos += sizeof(header);
-    
-    // write address
-    switch (remote_addr.type) {
-        case BADDR_TYPE_IPV4: {
-            struct udpgw_addr_ipv4 addr_ipv4;
-            addr_ipv4.addr_ip = remote_addr.ipv4.ip;
-            addr_ipv4.addr_port = remote_addr.ipv4.port;
-            memcpy(out + out_pos, &addr_ipv4, sizeof(addr_ipv4));
-            out_pos += sizeof(addr_ipv4);
-        } break;
-        case BADDR_TYPE_IPV6: {
-            struct udpgw_addr_ipv6 addr_ipv6;
-            memcpy(addr_ipv6.addr_ip, remote_addr.ipv6.ip, sizeof(addr_ipv6.addr_ip));
-            addr_ipv6.addr_port = remote_addr.ipv6.port;
-            memcpy(out + out_pos, &addr_ipv6, sizeof(addr_ipv6));
-            out_pos += sizeof(addr_ipv6);
-        } break;
+
+    if (!o->conaddr.is_dns) {
+        // write header
+        BAddr remote_addr = o->conaddr.remote_addr;
+        struct socks_udp_header header;
+        header.rsv = 0;
+        header.frag = 0;
+        if (remote_addr.type == BADDR_TYPE_IPV4) {
+            header.atyp = SOCKS_ATYP_IPV4;
+        } else {
+            header.atyp = SOCKS_ATYP_IPV6;
+        }
+        memcpy(out + out_pos, &header, sizeof(header));
+        out_pos += sizeof(header);
+
+        // write address
+        switch (remote_addr.type) {
+            case BADDR_TYPE_IPV4: {
+                struct udpgw_addr_ipv4 addr_ipv4;
+                addr_ipv4.addr_ip = remote_addr.ipv4.ip;
+                addr_ipv4.addr_port = remote_addr.ipv4.port;
+                memcpy(out + out_pos, &addr_ipv4, sizeof(addr_ipv4));
+                out_pos += sizeof(addr_ipv4);
+            } break;
+            case BADDR_TYPE_IPV6: {
+                struct udpgw_addr_ipv6 addr_ipv6;
+                memcpy(addr_ipv6.addr_ip, remote_addr.ipv6.ip, sizeof(addr_ipv6.addr_ip));
+                addr_ipv6.addr_port = remote_addr.ipv6.port;
+                memcpy(out + out_pos, &addr_ipv6, sizeof(addr_ipv6));
+                out_pos += sizeof(addr_ipv6);
+            } break;
+        }
     }
-    
+
     // write packet to buffer
     memcpy(out + out_pos, data, data_len);
     out_pos += data_len;
-    
+
     // submit written message
     BufferWriter_EndPacket(&o->udp_send_writer, out_pos);
+
+    // move connection to front of the list
+    time(&o->last_active_time);
+    LinkedList1_Remove(&o->client->connections_list, &o->connections_list_node);
+    LinkedList1_Append(&o->client->connections_list, &o->connections_list_node);
 }
 
 static void connection_first_job_handler (SocksUdpGwClient_connection *con)
@@ -241,68 +273,74 @@ static SocksUdpGwClient_connection *connection_init (SocksUdpGwClient *client, S
         BLog(BLOG_ERROR, "malloc failed");
         goto fail;
     }
-    
+
     // init arguments
     o->client = client;
     o->conaddr = conaddr;
     o->first_data = data;
     o->first_data_len = data_len;
-    
+    time(&o->last_active_time);
+
     // init first job
     BPending_Init(&o->first_job, BReactor_PendingGroup(client->reactor), (BPending_handler)connection_first_job_handler, o);
     BPending_Set(&o->first_job);
-    
+
     // init UDP dgram
     if (!BDatagram_Init(&o->udp_dgram, client->socks_server_addr.type, client->reactor, o, (BDatagram_handler)dgram_handler)) {
         goto fail0;
     }
-    
+
     // set SO_REUSEADDR
     if (!BDatagram_SetReuseAddr(&o->udp_dgram, 1)) {
         BLog(BLOG_ERROR, "set SO_REUSEADDR failed");
         goto fail1;
     }
-    
+
     // set UDP dgram send address
     BIPAddr ipaddr;
     memset(&ipaddr, 0, sizeof(ipaddr));
-    ipaddr.type = client->socks_server_addr.type;
-    BDatagram_SetSendAddrs(&o->udp_dgram, client->socks_server_addr, ipaddr);
-    
+    if (o->conaddr.is_dns) {
+        ipaddr.type = client->dnsgw.type;
+        BDatagram_SetSendAddrs(&o->udp_dgram, client->dnsgw, ipaddr);
+    } else {
+        ipaddr.type = client->socks_server_addr.type;
+        BDatagram_SetSendAddrs(&o->udp_dgram, client->socks_server_addr, ipaddr);
+    }
+
     // init UDP dgram interfaces
     BDatagram_SendAsync_Init(&o->udp_dgram, client->udp_mtu);
     BDatagram_RecvAsync_Init(&o->udp_dgram, client->udp_mtu);
-    
+
     // init UDP writer
     BufferWriter_Init(&o->udp_send_writer, client->udp_mtu, BReactor_PendingGroup(client->reactor));
-    
+
     // init UDP buffer
     if (!PacketBuffer_Init(&o->udp_send_buffer, BufferWriter_GetOutput(&o->udp_send_writer), BDatagram_SendAsync_GetIf(&o->udp_dgram), CONNECTION_UDP_BUFFER_SIZE, BReactor_PendingGroup(client->reactor))) {
         BLog(BLOG_ERROR, "PacketBuffer_Init failed");
         goto fail2;
     }
-    
+
     // init UDP recv interface
     PacketPassInterface_Init(&o->udp_recv_if, client->udp_mtu, (PacketPassInterface_handler_send)dgram_handler_received, o, BReactor_PendingGroup(client->reactor));
-    
+
     // init UDP recv buffer
     if (!SinglePacketBuffer_Init(&o->udp_recv_buffer, BDatagram_RecvAsync_GetIf(&o->udp_dgram), &o->udp_recv_if, BReactor_PendingGroup(client->reactor))) {
         BLog(BLOG_ERROR, "SinglePacketBuffer_Init failed");
         goto fail3;
     }
-    
+
     // insert to connections tree by conaddr
     ASSERT_EXECUTE(BAVL_Insert(&client->connections_tree, &o->connections_tree_node, NULL));
-    
+
     // insert to connections list
     LinkedList1_Append(&client->connections_list, &o->connections_list_node);
-    
+
     // increment number of connections
     client->num_connections++;
-    
+
     // succeed to init
     return o;
-    
+
 fail3:
     PacketPassInterface_Free(&o->udp_recv_if);
     PacketBuffer_Free(&o->udp_send_buffer);
@@ -312,7 +350,7 @@ fail2:
     BDatagram_SendAsync_Free(&o->udp_dgram);
 fail1:
     BDatagram_Free(&o->udp_dgram);
-    
+
 fail0:
     BPending_Free(&o->first_job);
     free(o);
@@ -323,35 +361,35 @@ fail:
 static void connection_free (SocksUdpGwClient_connection *o)
 {
     SocksUdpGwClient *client = o->client;
-    
+
     // decrement number of connections
     client->num_connections--;
-    
+
     // remove from connections list
     LinkedList1_Remove(&client->connections_list, &o->connections_list_node);
-    
+
     // remove from connections tree by conaddr
     BAVL_Remove(&client->connections_tree, &o->connections_tree_node);
-    
+
     // free UDP receive buffer
     SinglePacketBuffer_Free(&o->udp_recv_buffer);
-    
+
     // free UDP receive interface
     PacketPassInterface_Free(&o->udp_recv_if);
-    
+
     // free UDP buffer
     PacketBuffer_Free(&o->udp_send_buffer);
-    
+
     // free UDP writer
     BufferWriter_Free(&o->udp_send_writer);
-    
+
     // free UDP dgram interfaces
     BDatagram_RecvAsync_Free(&o->udp_dgram);
     BDatagram_SendAsync_Free(&o->udp_dgram);
-    
+
     // free UDP dgram
     BDatagram_Free(&o->udp_dgram);
-    
+
     // free structure
     free(o);
 }
@@ -416,7 +454,9 @@ static void socks_client_handler (SocksUdpGwClient *o, int event)
         case BSOCKSCLIENT_EVENT_UP: {
             ASSERT(!o->socks_up)
             
+#ifndef NDEBUG
             BLog(BLOG_INFO, "SOCKS up");
+#endif
             
             // connect udpgw client to SOCKS
             if (!UdpGwClient_ConnectServer(&o->udpgw_client, BSocksClient_GetSendInterface(&o->socks_client), BSocksClient_GetRecvInterface(&o->socks_client))) {
@@ -439,7 +479,9 @@ static void socks_client_handler (SocksUdpGwClient *o, int event)
         
         case BSOCKSCLIENT_EVENT_ERROR:
         case BSOCKSCLIENT_EVENT_ERROR_CLOSED: {
+#ifndef NDEBUG
             BLog(BLOG_INFO, "SOCKS error");
+#endif
             
             // free SOCKS
             free_socks(o);
@@ -480,7 +522,7 @@ static void udpgw_handler_received (SocksUdpGwClient *o, BAddr local_addr, BAddr
 
 int SocksUdpGwClient_Init (SocksUdpGwClient *o, int udp_mtu, int max_connections, int send_buffer_size, btime_t keepalive_time,
                            BAddr socks_server_addr, const struct BSocksClient_auth_info *auth_info, size_t num_auth_info,
-                           BAddr remote_udpgw_addr, btime_t reconnect_time, BReactor *reactor, void *user,
+                           BAddr remote_udpgw_addr, BAddr dnsgw, btime_t reconnect_time, BReactor *reactor, void *user,
                            SocksUdpGwClient_handler_received handler_received)
 {
     // see asserts in UdpGwClient_Init
@@ -488,30 +530,31 @@ int SocksUdpGwClient_Init (SocksUdpGwClient *o, int udp_mtu, int max_connections
 #ifndef BADVPN_SOCKS_UDP_RELAY
     ASSERT(remote_udpgw_addr.type == BADDR_TYPE_IPV4 || remote_udpgw_addr.type == BADDR_TYPE_IPV6)
 #endif
-    
+
     // init arguments
     o->udp_mtu = udp_mtu;
     o->socks_server_addr = socks_server_addr;
     o->auth_info = auth_info;
     o->num_auth_info = num_auth_info;
     o->remote_udpgw_addr = remote_udpgw_addr;
+    o->dnsgw = dnsgw;
     o->reactor = reactor;
     o->user = user;
     o->handler_received = handler_received;
-    
+
 #ifdef BADVPN_SOCKS_UDP_RELAY
     // compute MTUs
     o->udpgw_mtu = udpgw_compute_mtu(o->udp_mtu);
     o->max_connections = max_connections;
-    
+
     // limit max connections to number of conid's
     if (o->max_connections > UINT16_MAX + 1) {
         o->max_connections = UINT16_MAX + 1;
     }
-    
+
     // init connections tree by conaddr
     BAVL_Init(&o->connections_tree, OFFSET_DIFF(SocksUdpGwClient_connection, conaddr, connections_tree_node), (BAVL_comparator)conaddr_comparator, NULL);
-    
+
     // init connections list
     LinkedList1_Init(&o->connections_list);
 #else
@@ -532,10 +575,10 @@ int SocksUdpGwClient_Init (SocksUdpGwClient *o, int udp_mtu, int max_connections
     // try connecting
     try_connect(o);
 #endif
-    
+
     DebugObject_Init(&o->d_obj);
     return 1;
-    
+
 fail0:
     return 0;
 }
@@ -543,7 +586,7 @@ fail0:
 void SocksUdpGwClient_Free (SocksUdpGwClient *o)
 {
     DebugObject_Free(&o->d_obj);
-    
+
 #ifdef BADVPN_SOCKS_UDP_RELAY
     // free connections
     while (!LinkedList1_IsEmpty(&o->connections_list)) {
@@ -568,35 +611,38 @@ void SocksUdpGwClient_SubmitPacket (SocksUdpGwClient *o, BAddr local_addr, BAddr
 {
     DebugObject_Access(&o->d_obj);
     // see asserts in UdpGwClient_SubmitPacket
-    
+
 #ifdef BADVPN_SOCKS_UDP_RELAY
     ASSERT(local_addr.type == BADDR_TYPE_IPV4 || local_addr.type == BADDR_TYPE_IPV6)
     ASSERT(remote_addr.type == BADDR_TYPE_IPV4 || remote_addr.type == BADDR_TYPE_IPV6)
     ASSERT(data_len >= 0)
     ASSERT(data_len <= o->udp_mtu)
-    
+
     // build conaddr
     SocksUdpGwClient_conaddr conaddr;
     conaddr.local_addr = local_addr;
     conaddr.remote_addr = remote_addr;
-    
+    conaddr.is_dns = is_dns;
+
     // lookup connection
     SocksUdpGwClient_connection *con = find_connection(o, conaddr);
-    
-    // if no connection and can't create a new one, reuse the least recently used une
-    if (!con && o->num_connections == o->max_connections) {
-        con = reuse_connection(o, conaddr);
-    }
-    
+
     if (!con) {
+        // recycle outdated connections
+        if (o->num_connections > 0) {
+            recycle_connections(o);
+        }
+
+        // if max number of connections is reached, force recycle the least recently used une
+        if (o->num_connections >= o->max_connections) {
+            force_recycle_connection(o);
+        }
+
         // create new connection
-        con = connection_init(o, conaddr, data, data_len);
+        connection_init(o, conaddr, data, data_len);
     } else {
-        // move connection to front of the list
-        LinkedList1_Remove(&o->connections_list, &con->connections_list_node);
-        LinkedList1_Append(&o->connections_list, &con->connections_list_node);
-        
         // send packet to existing connection
+        con->conaddr.remote_addr = remote_addr;
         connection_send(con, data, data_len);
     }
 #else
diff --git a/tun2socks/SocksUdpGwClient.h b/tun2socks/SocksUdpGwClient.h
index eeda371..1ba401c 100644
--- a/tun2socks/SocksUdpGwClient.h
+++ b/tun2socks/SocksUdpGwClient.h
@@ -55,6 +55,7 @@ typedef struct {
     const struct BSocksClient_auth_info *auth_info;
     size_t num_auth_info;
     BAddr remote_udpgw_addr;
+    BAddr dnsgw;
     BReactor *reactor;
     void *user;
     SocksUdpGwClient_handler_received handler_received;
@@ -78,6 +79,7 @@ typedef struct {
 typedef struct {
     BAddr local_addr;
     BAddr remote_addr;
+    int is_dns;
 } SocksUdpGwClient_conaddr;
 
 typedef struct {
@@ -91,6 +93,7 @@ typedef struct {
     PacketBuffer udp_send_buffer;
     SinglePacketBuffer udp_recv_buffer;
     PacketPassInterface udp_recv_if;
+    time_t last_active_time;
     BAVLNode connections_tree_node;
     LinkedList1Node connections_list_node;
 } SocksUdpGwClient_connection;
@@ -98,7 +101,7 @@ typedef struct {
 
 int SocksUdpGwClient_Init (SocksUdpGwClient *o, int udp_mtu, int max_connections, int send_buffer_size, btime_t keepalive_time,
                            BAddr socks_server_addr, const struct BSocksClient_auth_info *auth_info, size_t num_auth_info,
-                           BAddr remote_udpgw_addr, btime_t reconnect_time, BReactor *reactor, void *user,
+                           BAddr remote_udpgw_addr, BAddr dnsgw, btime_t reconnect_time, BReactor *reactor, void *user,
                            SocksUdpGwClient_handler_received handler_received) WARN_UNUSED;
 void SocksUdpGwClient_Free (SocksUdpGwClient *o);
 void SocksUdpGwClient_SubmitPacket (SocksUdpGwClient *o, BAddr local_addr, BAddr remote_addr, int is_dns, const uint8_t *data, int data_len);
diff --git a/tun2socks/tun2socks.c b/tun2socks/tun2socks.c
index 3898b26..ba08045 100644
--- a/tun2socks/tun2socks.c
+++ b/tun2socks/tun2socks.c
@@ -2,7 +2,7 @@
  * Copyright (C) Ambroz Bizjak <ambrop7@gmail.com>
  * Contributions:
  * Transparent DNS: Copyright (C) Kerem Hadimli <kerem.hadimli@gmail.com>
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -13,7 +13,7 @@
  * 3. Neither the name of the author nor the
  *    names of its contributors may be used to endorse or promote products
  *    derived from this software without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -98,6 +98,8 @@ struct {
     #endif
     int loglevel;
     int loglevels[BLOG_NUM_CHANNELS];
+    int tunfd;
+    int tunmtu;
     char *tundev;
     char *netif_ipaddr;
     char *netif_netmask;
@@ -111,6 +113,7 @@ struct {
     int udpgw_max_connections;
     int udpgw_connection_buffer_size;
     int udpgw_transparent_dns;
+    char *dnsgw;
 } options;
 
 // TCP client
@@ -159,6 +162,9 @@ size_t socks_num_auth_info;
 // remote udpgw server addr, if provided
 BAddr udpgw_remote_server_addr;
 
+// dnsgw addr, if provided
+BAddr dnsgw;
+
 // reactor
 BReactor ss;
 
@@ -332,7 +338,17 @@ int main (int argc, char **argv)
     }
     
     // init TUN device
-    if (!BTap_Init(&device, &ss, options.tundev, device_error_handler, NULL, 1)) {
+    struct BTap_init_data init_data;
+    init_data.dev_type = BTAP_DEV_TUN;
+    if (options.tundev) {
+        init_data.init_type = BTAP_INIT_STRING;
+        init_data.init.string = options.tundev;
+    } else {
+        init_data.init_type = BTAP_INIT_FD;
+        init_data.init.fd.fd = options.tunfd;
+        init_data.init.fd.mtu = options.tunmtu;
+    }
+    if (!BTap_Init2(&device, &ss, init_data, device_error_handler, NULL)) {
         BLog(BLOG_ERROR, "BTap_Init failed");
         goto fail3;
     }
@@ -372,7 +388,7 @@ int main (int argc, char **argv)
         // init udpgw client
         if (!SocksUdpGwClient_Init(&udpgw_client, udp_mtu, DEFAULT_UDPGW_MAX_CONNECTIONS, options.udpgw_connection_buffer_size, UDPGW_KEEPALIVE_TIME,
                                    socks_server_addr, socks_auth_info, socks_num_auth_info,
-                                   udpgw_remote_server_addr, UDPGW_RECONNECT_TIME, &ss, NULL, udpgw_client_handler_received
+                                   udpgw_remote_server_addr, dnsgw, UDPGW_RECONNECT_TIME, &ss, NULL, udpgw_client_handler_received
         )) {
             BLog(BLOG_ERROR, "SocksUdpGwClient_Init failed");
             goto fail4a;
@@ -486,6 +502,7 @@ void print_help (const char *name)
         #endif
         "        [--loglevel <0-5/none/error/warning/notice/info/debug>]\n"
         "        [--channel-loglevel <channel-name> <0-5/none/error/warning/notice/info/debug>] ...\n"
+        "        [--tunfd <fd> --tunmtu <mtu>]\n"
         "        [--tundev <name>]\n"
         "        --netif-ipaddr <ipaddr>\n"
         "        --netif-netmask <ipnetmask>\n"
@@ -498,6 +515,7 @@ void print_help (const char *name)
 #ifdef BADVPN_SOCKS_UDP_RELAY
         "        [--enable-udprelay]\n"
         "        [--udprelay-max-connections <number>]\n"
+        "        [--dnsgw <addr>]\n"
 #else
         "        [--udpgw-remote-server-addr <addr>]\n"
         "        [--udpgw-max-connections <number>]\n"
@@ -531,6 +549,8 @@ int parse_arguments (int argc, char *argv[])
     for (int i = 0; i < BLOG_NUM_CHANNELS; i++) {
         options.loglevels[i] = -1;
     }
+    options.tunfd = 0;
+    options.tunmtu = 0;
     options.tundev = NULL;
     options.netif_ipaddr = NULL;
     options.netif_netmask = NULL;
@@ -544,6 +564,7 @@ int parse_arguments (int argc, char *argv[])
     options.udpgw_max_connections = DEFAULT_UDPGW_MAX_CONNECTIONS;
     options.udpgw_connection_buffer_size = DEFAULT_UDPGW_CONNECTION_BUFFER_SIZE;
     options.udpgw_transparent_dns = 0;
+    options.dnsgw = NULL;
     
     int i;
     for (i = 1; i < argc; i++) {
@@ -621,6 +642,22 @@ int parse_arguments (int argc, char *argv[])
             options.loglevels[channel] = loglevel;
             i += 2;
         }
+        else if (!strcmp(arg, "--tunfd")) {
+            if (1 >= argc - i) {
+                fprintf(stderr, "%s: requires an argument\n", arg);
+                return 0;
+            }
+            options.tunfd = atoi(argv[i + 1]);
+            i++;
+        }
+        else if (!strcmp(arg, "--tunmtu")) {
+            if (1 >= argc - i) {
+                fprintf(stderr, "%s: requires an argument\n", arg);
+                return 0;
+            }
+            options.tunmtu = atoi(argv[i + 1]);
+            i++;
+        }
         else if (!strcmp(arg, "--tundev")) {
             if (1 >= argc - i) {
                 fprintf(stderr, "%s: requires an argument\n", arg);
@@ -716,7 +753,16 @@ int parse_arguments (int argc, char *argv[])
             }
             i++;
         }
-#ifndef BADVPN_SOCKS_UDP_RELAY
+#ifdef BADVPN_SOCKS_UDP_RELAY
+        else if (!strcmp(arg, "--dnsgw")) {
+            if (1 >= argc - i) {
+                fprintf(stderr, "%s: requires an argument\n", arg);
+                return 0;
+            }
+            options.dnsgw = argv[i + 1];
+            i++;
+        }
+#else
         else if (!strcmp(arg, "--udpgw-connection-buffer-size")) {
             if (1 >= argc - i) {
                 fprintf(stderr, "%s: requires an argument\n", arg);
@@ -847,6 +893,14 @@ int process_arguments (void)
         }
     }
     
+    // resolve dnsgw address
+    if (options.dnsgw) {
+        if (!BAddr_Parse2(&dnsgw, options.dnsgw, NULL, 0, 0)) {
+            BLog(BLOG_ERROR, "dnsgw addr: BAddr_Parse2 failed");
+            return 0;
+        }
+    }
+    
     return 1;
 }
 
@@ -1000,7 +1054,9 @@ void device_read_handler_send (void *unused, uint8_t *data, int data_len)
     ASSERT(!quitting)
     ASSERT(data_len >= 0)
     
+#ifndef NDEBUG
     BLog(BLOG_DEBUG, "device: received packet");
+#endif
     
     // accept packet
     PacketPassInterface_Done(&device_read_interface);
@@ -1012,12 +1068,16 @@ void device_read_handler_send (void *unused, uint8_t *data, int data_len)
     
     // obtain pbuf
     if (data_len > UINT16_MAX) {
+#ifndef NDEBUG
         BLog(BLOG_WARNING, "device read: packet too large");
+#endif
         return;
     }
     struct pbuf *p = pbuf_alloc(PBUF_RAW, data_len, PBUF_POOL);
     if (!p) {
+#ifndef NDEBUG
         BLog(BLOG_WARNING, "device read: pbuf_alloc failed");
+#endif
         return;
     }
     
@@ -1026,7 +1086,9 @@ void device_read_handler_send (void *unused, uint8_t *data, int data_len)
     
     // pass pbuf to input
     if (the_netif.input(p, &the_netif) != ERR_OK) {
+#ifndef NDEBUG
         BLog(BLOG_WARNING, "device read: input failed");
+#endif
         pbuf_free(p);
     }
 }
@@ -1068,6 +1130,7 @@ int process_device_udp_packet (uint8_t *data, int data_len)
                 goto fail;
             }
             
+#if CHECKSUM_CHECK_UDP
             // verify UDP checksum
             uint16_t checksum_in_packet = udp_header.checksum;
             udp_header.checksum = 0;
@@ -1075,18 +1138,25 @@ int process_device_udp_packet (uint8_t *data, int data_len)
             if (checksum_in_packet != checksum_computed) {
                 goto fail;
             }
+#endif
             
+#ifndef NDEBUG
             BLog(BLOG_INFO, "UDP: from device %d bytes", data_len);
+#endif
             
             // construct addresses
             BAddr_InitIPv4(&local_addr, ipv4_header.source_address, udp_header.source_port);
             BAddr_InitIPv4(&remote_addr, ipv4_header.destination_address, udp_header.dest_port);
-            
-            // if transparent DNS is enabled, any packet arriving at out netif
-            // address to port 53 is considered a DNS packet
-            is_dns = (options.udpgw_transparent_dns &&
-                      ipv4_header.destination_address == netif_ipaddr.ipv4 &&
-                      udp_header.dest_port == hton16(53));
+
+            if (options.dnsgw) {
+                is_dns = udp_header.dest_port == hton16(53);
+            } else {
+                // if transparent DNS is enabled, any packet arriving at out netif
+                // address to port 53 is considered a DNS packet
+                is_dns = (options.udpgw_transparent_dns &&
+                        ipv4_header.destination_address == netif_ipaddr.ipv4 &&
+                        udp_header.dest_port == hton16(53));
+            }
         } break;
         
         case 6: {
@@ -1112,6 +1182,7 @@ int process_device_udp_packet (uint8_t *data, int data_len)
                 goto fail;
             }
             
+#if CHECKSUM_CHECK_UDP
             // verify UDP checksum
             uint16_t checksum_in_packet = udp_header.checksum;
             udp_header.checksum = 0;
@@ -1119,8 +1190,11 @@ int process_device_udp_packet (uint8_t *data, int data_len)
             if (checksum_in_packet != checksum_computed) {
                 goto fail;
             }
+#endif
             
+#ifndef NDEBUG
             BLog(BLOG_INFO, "UDP/IPv6: from device %d bytes", data_len);
+#endif
             
             // construct addresses
             BAddr_InitIPv6(&local_addr, ipv6_header.source_address, udp_header.source_port);
@@ -1137,10 +1211,12 @@ int process_device_udp_packet (uint8_t *data, int data_len)
     
     // check payload length
     if (data_len > udp_mtu) {
+#ifndef NDEBUG
 #ifdef BADVPN_SOCKS_UDP_RELAY
         BLog(BLOG_ERROR, "packet is too large, cannot send to udprelay");
 #else
         BLog(BLOG_ERROR, "packet is too large, cannot send to udpgw");
+#endif
 #endif
         goto fail;
     }
@@ -1180,7 +1256,9 @@ err_t common_netif_output (struct netif *netif, struct pbuf *p)
 {
     SYNC_DECL
     
+#ifndef NDEBUG
     BLog(BLOG_DEBUG, "device write: send packet");
+#endif
     
     if (quitting) {
         return ERR_OK;
@@ -1189,7 +1267,9 @@ err_t common_netif_output (struct netif *netif, struct pbuf *p)
     // if there is just one chunk, send it directly, else via buffer
     if (!p->next) {
         if (p->len > BTap_GetMTU(&device)) {
+#ifndef NDEBUG
             BLog(BLOG_WARNING, "netif func output: no space left");
+#endif
             goto out;
         }
         
@@ -1200,7 +1280,9 @@ err_t common_netif_output (struct netif *netif, struct pbuf *p)
         int len = 0;
         do {
             if (p->len > BTap_GetMTU(&device) - len) {
+#ifndef NDEBUG
                 BLog(BLOG_WARNING, "netif func output: no space left");
+#endif
                 goto out;
             }
             memcpy(device_write_buf + len, p->payload, p->len);
@@ -1250,10 +1332,12 @@ void client_logfunc (struct tcp_client *client)
 
 void client_log (struct tcp_client *client, int level, const char *fmt, ...)
 {
+#ifndef NDEBUG
     va_list vl;
     va_start(vl, fmt);
     BLog_LogViaFuncVarArg((BLog_logfunc)client_logfunc, client, BLOG_CURRENT_CHANNEL, level, fmt, vl);
     va_end(vl);
+#endif
 }
 
 err_t listener_accept_func (void *arg, struct tcp_pcb *newpcb, err_t err)
@@ -1812,16 +1896,20 @@ void udpgw_client_handler_received (void *unused, BAddr local_addr, BAddr remote
     
     switch (local_addr.type) {
         case BADDR_TYPE_IPV4: {
+#ifndef NDEBUG
 #ifdef BADVPN_SOCKS_UDP_RELAY
             BLog(BLOG_INFO, "UDP: from udprelay %d bytes", data_len);
 #else
             BLog(BLOG_INFO, "UDP: from udpgw %d bytes", data_len);
+#endif
 #endif
             
             if (data_len > UINT16_MAX - (sizeof(struct ipv4_header) + sizeof(struct udp_header)) ||
                 data_len > BTap_GetMTU(&device) - (int)(sizeof(struct ipv4_header) + sizeof(struct udp_header))
             ) {
+#ifndef NDEBUG
                 BLog(BLOG_ERROR, "UDP: packet is too large");
+#endif
                 return;
             }
             
@@ -1855,17 +1943,21 @@ void udpgw_client_handler_received (void *unused, BAddr local_addr, BAddr remote
         } break;
         
         case BADDR_TYPE_IPV6: {
+#ifndef NDEBUG
 #ifdef BADVPN_SOCKS_UDP_RELAY
             BLog(BLOG_INFO, "UDP/IPv6: from udprelay %d bytes", data_len);
 #else
             BLog(BLOG_INFO, "UDP/IPv6: from udpgw %d bytes", data_len);
+#endif
 #endif
             
             if (!options.netif_ip6addr) {
+#ifndef NDEBUG
 #ifdef BADVPN_SOCKS_UDP_RELAY
                 BLog(BLOG_ERROR, "got IPv6 packet from udprelay but IPv6 is disabled");
 #else
                 BLog(BLOG_ERROR, "got IPv6 packet from udpgw but IPv6 is disabled");
+#endif
 #endif
                 return;
             }
@@ -1873,7 +1965,9 @@ void udpgw_client_handler_received (void *unused, BAddr local_addr, BAddr remote
             if (data_len > UINT16_MAX - sizeof(struct udp_header) ||
                 data_len > BTap_GetMTU(&device) - (int)(sizeof(struct ipv6_header) + sizeof(struct udp_header))
             ) {
+#ifndef NDEBUG
                 BLog(BLOG_ERROR, "UDP/IPv6: packet is too large");
+#endif
                 return;
             }
             
diff --git a/tun2socks/tun2socks.h b/tun2socks/tun2socks.h
index caf5778..d81e649 100644
--- a/tun2socks/tun2socks.h
+++ b/tun2socks/tun2socks.h
@@ -25,10 +25,10 @@
  */
 
 // name of the program
-#define PROGRAM_NAME "tun2socks"
+#define PROGRAM_NAME "TUN processor"
 
 // size of temporary buffer for passing data from the SOCKS server to TCP for sending
-#define CLIENT_SOCKS_RECV_BUF_SIZE 8192
+#define CLIENT_SOCKS_RECV_BUF_SIZE 4096
 
 // maximum number of udpgw connections
 #define DEFAULT_UDPGW_MAX_CONNECTIONS 256
